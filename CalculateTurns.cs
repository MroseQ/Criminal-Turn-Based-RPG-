using System;using System.Collections;using System.Collections.Generic;using System.Linq;using System.Security.Cryptography;using TMPro;using UnityEditor;using UnityEngine;using UnityEngine.SceneManagement;using UnityEngine.UI;using static UnityEngine.GraphicsBuffer;public class CalculateTurns : MonoBehaviour{    public List<TurnID> turnAllocation = new();    [SerializeField] private int indexToSet = 1, changeStateAt;    public List<CharactersParameters> charParameters = new List<CharactersParameters>();    public bool changeTurn, actionPerformed, playerMove, isCorrectPick, gameStarted, isChanging,gameFinished, _add;    public delegate void TurnFillMessage(TurnID message);    public static event TurnFillMessage MessageToFill;    public delegate void ActionPerformed(bool msg);    public static event ActionPerformed MessageOfActionPerformed;    public delegate void ChangeTurnMessage(TurnID message);    public static event ChangeTurnMessage ChangeTurn;    public delegate void DeleteTurn(TurnID message);    public static event DeleteTurn Deletion;    public TextMeshProUGUI lastUsedSkill, pickInfo;    public float lastUsedGradientSpeed;    public GameObject canvas, blackScreen, fragments;    public AudioHandle characterAudio, magicAudio;    [SerializeField] private CameraFieldOfView fieldOfView;    private EffectDetails effectToReceive;    [SerializeField] private CharactersParameters attacking, boss, attackingHolder;    public List<CharactersParameters> targets = new List<CharactersParameters>();    private SkillDetails usingSkill;    [SerializeField] SpawnScriptableObject SO;    void Start()    {        SO.battleOutcome = false;        foreach (CharactersParameters obj in charParameters)        {            obj.characterObject.transform.localPosition = new(-8, obj.characterObject.transform.localPosition.y, obj.characterObject.transform.localPosition.z);            if (obj.enemy && obj.name != "Mrożon")            {                obj.IsDead = true;            }        }        foreach (CharactersParameters obj in charParameters.FindAll(c => !c.IsDead))        {            StartCoroutine(SetCharacter(obj));        }        effectToReceive = new("Repeat", 999, "effblue", "EffectsTexture/Repeat Texture", boss);        StartCoroutine(ChangeToFinish());        StartCoroutine(StartTheGame());    }    public IEnumerator SetCharacter(CharactersParameters param, int currentSpeed = 0)    {        param.IsDead = false;        turnAllocation.Add(new(param, currentSpeed + param.speed));        turnAllocation.Add(new(param, currentSpeed + (param.speed * 2)));        yield return new WaitWhile(() => blackScreen.activeSelf);        param.characterObject.SetActive(true);        param.charPanel.GetComponent<Animator>().SetTrigger("Start");        param.characterObject.GetComponent<Animator>().SetTrigger("Start");        yield return new WaitWhile(() => param.characterObject.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).IsName("New State"));        yield return new WaitUntil(() => param.characterObject.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 1);        //param.characterObject.GetComponent<Animator>().enabled = false;    }    public void RemoveCharacter(CharactersParameters target)    {        target.characterObject.GetComponent<Animator>().runtimeAnimatorController = Resources.Load<RuntimeAnimatorController>("Text/CharacterFade");        target.characterObject.GetComponent<Animator>().enabled = true;        target.charPanel.GetComponent<Animator>().SetTrigger("Hide");        target.currentHP = 0;        target.IsDead = true;        charParameters.Remove(target);        foreach (TurnID turn in turnAllocation.Where(t => t.name == target.name && t.obj != null))        {            Deletion.Invoke(turn);        }        turnAllocation.RemoveAll(t => t.name == target.name);    }    void Update()    {        if (_add)        {            _add = false;            ReceiveEffect(new("Bleed", 5, "effgreen", "EffectsTexture/Slowed Down Texture", charParameters.Find(a => a.name == "Meeko"), 60,1), false);        }        foreach (CharactersParameters param in charParameters)        {            if (param.effects.Exists(e => e.effectName == "Sped Up" || e.effectName == "Slowed Down"))            {                foreach (EffectDetails eff in param.effects.FindAll(e => (e.effectName == "Sped Up" || e.effectName == "Slowed Down") && e.effectValue != 0))                {                    List<TurnID> turns = turnAllocation.FindAll(t => t.character == param);                    foreach (TurnID turn in turns)                    {                        turn.speed += eff.effectValue;                    }                    eff.effectValue = 0;                }            }        }        if (boss.currentHP <= changeStateAt)        {            if (boss.currentHP <= 0)            {                SO.battleOutcome = true;            }
            else
            {
                ReceiveEffect(effectToReceive, true);
                effectToReceive = new("Plot Armor", 999, "effblue", "EffectsTexture/Plot Armor Texture", boss);
                GetComponent<StartGameAudio>().sourceSwitch = true;
            }            changeStateAt -= 333;
            if (changeStateAt == 0)
            {
                foreach (CharactersParameters param in charParameters.FindAll(c => c.IsDead && c.enemy))
                {
                    param.currentSpeed = turnAllocation[0].speed + param.speed;
                    StartCoroutine(SetCharacter(param, turnAllocation[0].speed));
                }
            }        }        isChanging = false;        if (gameStarted && attacking != attackingHolder)        {            attackingHolder = attacking;            isChanging = true;            turnAllocation = turnAllocation.OrderBy(c => c.speed).ToList();            foreach (TurnID t in turnAllocation.FindAll(t => t.ID == 0)){
                t.SetIdentifier(indexToSet);
                indexToSet++;
                MessageToFill.Invoke(t);
            }        }        if (changeTurn && !isChanging && !gameFinished)        {            changeTurn = false;            turnAllocation = turnAllocation.OrderBy(c => c.speed).ToList();            StartCoroutine(MakeTurnOf(turnAllocation[0].name));        }    }    IEnumerator StartTheGame()
    {
        yield return new WaitWhile(() => blackScreen.activeSelf);
        foreach (CharactersParameters c in charParameters.FindAll(c => c.IsDead))
        {
            c.characterObject.SetActive(false);
        }
        turnAllocation = turnAllocation.OrderBy(c => c.speed).ToList();
        StartCoroutine(MakeTurnOf(turnAllocation[0].name));        gameStarted = true;
    }    private class SpeedOf    {        public int speed;        public CharactersParameters character;        public SpeedOf(int s, CharactersParameters c)        {            speed = s;            character = c;        }    }    [System.Serializable]    public class TurnID    {        public string name;        [SerializeField]        public int ID = 0;        public GameObject obj;        public int speed;        public CharactersParameters character;        public TurnID(CharactersParameters c, int spd)        {            name = c.name;            speed = spd;            character = c;        }        public void SetIdentifier(int id)        {            ID = id;        }    }    public IEnumerator MakeTurnOf(string name)    {        targets = new();        yield return new WaitWhile(() => blackScreen.activeSelf);        isCorrectPick = false;        MessageOfActionPerformed.Invoke(false);        attacking = Resources.Load<CharactersParameters>("Characters/" + name);        if(!charParameters.Any(c => c.enemy != attacking.enemy))
        {
            yield break;
        }        attacking.currentSpeed = turnAllocation.Find(t => t.character == attacking).speed;        attacking.currentCritChance = attacking.critChance;        attacking.currentDodgeChance = attacking.dodgeChance;        if (attacking.effects.Exists(effect => effect.effectName == "Unfreeze"))        {            EffectDetails effect = attacking.effects.Find(effect => effect.effectName == "Unfreeze");            int manaValue = GetDmg(false, effect.effectValue, effect.effectValueRange);            ReceiveMana(attacking, manaValue);        }        if (!attacking.effects.Exists(effect => effect.effectName == "Stun"))        {            yield return new WaitForSecondsRealtime(1f);            List<SkillDetails> availableSkills = new();            foreach (SkillDetails skill in attacking.skills)            {                if (skill.nowSkillCooldown == 0 && skill.skillManaDrain <= attacking.currentMana)                {                    availableSkills.Add(skill);                }            }            if (!attacking.enemy)            {                StartCoroutine(PlayerTurnMove());            }            else            {                availableSkills = ExcludeSkills(attacking, availableSkills);                while (!isCorrectPick)                {                    int index = UnityEngine.Random.Range(0, availableSkills.Count);                    targets = LoadTargets(availableSkills[index].skillTarget);                    if (targets.Count > 0)                    {                        usingSkill = availableSkills[index];                        if (usingSkill.skillTarget == "ally" || usingSkill.skillTarget == "enemy")                        {                            bool isProvocated = false;                            List<CharactersParameters> limitedTargets = new();                            foreach (CharactersParameters target in targets)                            {                                if (usingSkill.skillName == "Insulin Shot" && target.currentHP > target.maxHP - 50)                                {                                    limitedTargets.Add(target);                                }                                if (target.effects.Exists(effect => effect.effectName == "Provocation") && usingSkill.skillTarget == "enemy")                                {                                    if (!isProvocated)                                    {                                        targets = new();                                        isProvocated = true;                                    }                                    targets.Add(target);                                }                            }                            if (limitedTargets.Count > 0)                            {                                foreach (CharactersParameters limited in limitedTargets)                                {                                    targets.Remove(limited);                                }                            }                            if (!isProvocated)                            {                                int targetIndex = UnityEngine.Random.Range(0, targets.Count);                                CharactersParameters randomTarget = targets[targetIndex];                                targets = new() { randomTarget };                            }                        }                        isCorrectPick = true;                        lastUsedSkill.text = usingSkill.skillName;                        StartCoroutine(LastUsedSkillGradientChange(new Color(1f, 0f, 0f, 1f)));                    }                }                StartCoroutine(PerformSkill());            }            yield return new WaitUntil(() => actionPerformed);            usingSkill.nowSkillCooldown = usingSkill.skillCooldown;            MessageOfActionPerformed.Invoke(true);        }        else        {            foreach(EffectDetails eff in attacking.effects.FindAll(e => e.effectName == "Stun"))
            {
                StartCoroutine(RemoveEffect(eff, attacking));
            }            CreateText("DamageInfo", attacking.parentTransform, "stunned", new(1f, 1f, 0.4f, 1f));            yield return new WaitForSecondsRealtime(0.6f);        }        foreach (SkillDetails skill in attacking.skills)        {            if (skill.nowSkillCooldown != 0)            {                skill.nowSkillCooldown--;            }        }        yield return new WaitForSeconds(0.5f);        if (attacking.effects.Exists(effect => effect.effectName == "Bleed" || effect.effectName == "Respiration"))        {            int dmg = 0, heal = 0;            foreach (EffectDetails effect in attacking.effects.FindAll(effect => effect.effectName == "Bleed"))            {                dmg += GetDmg(false, effect.effectValue, effect.effectValueRange);            }            foreach (EffectDetails effect in attacking.effects.FindAll(effect => effect.effectName == "Respiration"))            {                heal += GetDmg(false, effect.effectValue, effect.effectValueRange);            }            if (heal > dmg)            {                heal -= dmg;                Heal(attacking, heal, false, new(0f, 1f, 0.35f, 1f));            }            else if (heal < dmg) {                dmg -= heal;                ReceiveDamage(attacking, new(1f, 0.1f, 0f, 1f), dmg, false, true);            }        }        actionPerformed = false;        if (!attacking.IsDead)
        {
            if (attacking.effects.Exists(effect => effect.effectName == "Repeat" && effect.effectValue == 0))            {                foreach (EffectDetails effect in attacking.effects)                {                    if (effect.effectName == "Repeat")                    {                        effect.effectValue++;                    }                    effect.effectDuration--;                    if (effect.effectDuration == 0)                    {                        StartCoroutine(RemoveEffect(effect, attacking));                    }                    else if (effect.effectObject.activeSelf)                    {                        effect.effectObject.transform.Find("Description").Find("EffectDuration").Find("Number").GetComponent<TextMeshProUGUI>().text = effect.effectDuration.ToString();                    }                }                StartCoroutine(MakeTurnOf(attacking.name));            }            else            {                foreach (EffectDetails effect in attacking.effects)                {                    if (effect.effectName == "Repeat")                    {                        effect.effectValue = 0;                    }                    effect.effectDuration--;                    if (effect.effectDuration == 0)                    {                        StartCoroutine(RemoveEffect(effect, attacking));                    }                    else if (effect.effectObject.activeSelf)                    {                        effect.effectObject.transform.Find("Description").Find("EffectDuration").Find("Number").GetComponent<TextMeshProUGUI>().text = effect.effectDuration.ToString();                    }                }                attacking.currentSpeed += attacking.speed;                ChangeTurn.Invoke(turnAllocation[0]);                turnAllocation.RemoveAt(0);                turnAllocation.Add(new(attacking, attacking.currentSpeed + attacking.speed));                turnAllocation.Find(t => t.name == attacking.name).speed = attacking.currentSpeed;                foreach (EffectDetails effect in attacking.effects.FindAll(effect => effect.effectName == "Sped Up"))                {                    effect.effectValue = -40;                }                foreach (EffectDetails effect in attacking.effects.FindAll(effect => effect.effectName == "Slowed Down"))                {                    effect.effectValue = 35;                }                changeTurn = true;            }
        }
        else
        {
            changeTurn = true;
        }    }    private IEnumerator PlayerTurnMove()    {        playerMove = false;        OrbAnimation.PickedSkill += HandlePickedSkill;        attacking.skillsPos.SetActive(true);        void HandlePickedSkill(string skill)        {            foreach (SkillDetails skillFromCharacter in attacking.skills)            {                if (skillFromCharacter.skillName == skill)                {                    if (skillFromCharacter.nowSkillCooldown == 0)                    {                        if (skillFromCharacter.skillManaDrain <= attacking.currentMana)                        {                            targets = LoadTargets(skillFromCharacter.skillTarget);                            if (targets.Count > 0)                            {                                usingSkill = skillFromCharacter;                                isCorrectPick = true;                            }                            else                            {                                canvas.GetComponent<ErrorCreation>().Create("Umiejętność nie ma żadnego celu do wyboru.");                            }                        }                        else                        {                            canvas.GetComponent<ErrorCreation>().Create("Brak many by użyć umiejętność.");                        }                    }                    else                    {                        canvas.GetComponent<ErrorCreation>().Create("Umiejętność nie zdążyła ochłonąć.");                    }                }            }        }        yield return new WaitUntil(() => isCorrectPick);        OrbAnimation.PickedSkill -= HandlePickedSkill;        lastUsedSkill.text = usingSkill.skillName;        StartCoroutine(LastUsedSkillGradientChange(new Color(0f, 1f, 0f, 1f)));        if ((usingSkill.skillTarget == "enemy" || usingSkill.skillTarget == "ally") && targets.Count != 1)        {            StartCoroutine(PlayerPickSpecificTarget(usingSkill.skillTarget));        }        else        {            playerMove = true;        }        yield return new WaitUntil(() => playerMove);        StartCoroutine(PerformSkill());    }    private IEnumerator PlayerPickSpecificTarget(string skillTarget)    {        yield return new WaitForSecondsRealtime(0.5f);        if (skillTarget == "ally")        {            pickInfo.text = "Wybierz sojusznika";        }        else        {            pickInfo.text = "Wybierz przeciwnika";        }        pickInfo.gameObject.SetActive(true);        yield return new WaitUntil(() => GetComponent<OutlineHandler>().confirmed != null);        targets = new();        targets.Add(GetComponent<OutlineHandler>().confirmed);        StartCoroutine(AlphaChange(pickInfo.gameObject));        playerMove = true;    }    private IEnumerator PerformSkill()    {        PerformAction();        yield return new WaitUntil(() => actionPerformed);        StartCoroutine(AlphaChange(lastUsedSkill.gameObject));    }    private List<CharactersParameters> LoadTargets(string target)    {        List<CharactersParameters> targets = new();        if (target == "self")        {            targets.Add(attacking);        }        else if (target == "allAllies" || target == "ally")        {            if (attacking.enemy)            {                foreach (CharactersParameters character in charParameters)                {                    if (character.enemy && !character.IsDead)                    {                        targets.Add(character);                    }                }            }            else            {                foreach (CharactersParameters character in charParameters)                {                    if (!character.enemy && !character.IsDead)                    {                        targets.Add(character);                    }                }            }        }        else if (target == "allEnemies" || target == "enemy")        {            if (attacking.enemy)            {                foreach (CharactersParameters character in charParameters)                {                    if (!character.enemy && !character.IsDead)                    {                        targets.Add(character);                    }                }            }            else            {                foreach (CharactersParameters character in charParameters)                {                    if (character.enemy && !character.IsDead)                    {                        targets.Add(character);                    }                }            }        }        else if (target == "boss")        {            targets.Add(charParameters.Find(target => target.IsBoss));        }        else        {            print(target + "  Błąd targetu");      // do usunięcia        }        return targets;    }    private void PerformAction()    {        Dictionary<string, Action> actionMap = new()        {            { "Ice Cone",() => StartCoroutine(PerformIceCone())},            { "Snowball",() => StartCoroutine(PerformSnowball())},            { "Solid Ice",() => StartCoroutine(PerformSolidIce())},            { "Freezing Gun",() => StartCoroutine(PerformFreezingGun())},            { "Shattered Ice",() => StartCoroutine(PerformShatteredIce())},            { "Ice Wallow",() => StartCoroutine(PerformIceWallow())},            { "Blood Freeze",() => StartCoroutine(PerformBloodFreeze())},            { "Slip And Slide",() => StartCoroutine(PerformSlipAndSlide())},            { "Gacha Addict",() => StartCoroutine(PerformGachaAddict())},            { "Power of Friendship",() => StartCoroutine(PerformFriendship())},            { "Killjoy",() => StartCoroutine(PerformKilljoy())},            { "High Ping",() => StartCoroutine(PerformHighPing())},            { "Cuteness Overload",() => StartCoroutine(PerformCuteness())},            { "Ace",() => StartCoroutine(PerformAce())},            { "Shotgun",() => StartCoroutine(PerformShotgun())},            { "Precise Shot",() => StartCoroutine(PerformPreciseShot())},            { "Target",() => StartCoroutine(PerformTarget())},            { "Knife Stab",() => StartCoroutine(PerformKnifeStab())},            { "Fire Dragon",() => StartCoroutine(PerformFireDragon())},            { "Hack",() => StartCoroutine(PerformHack())},            { "Pawulon's Nemesis",() => StartCoroutine(PerformNemesis())},            { "Insulin Shot",() => StartCoroutine(PerformInsulinShot())},            { "Richard's Blade",() => StartCoroutine(PerformRichard())},            { "Game's Bug",() => StartCoroutine(PerformGameBug())},            { "Woroh's Hair",() => StartCoroutine(PerformHair())},            { "Mrożon's Turn",() => StartCoroutine(PerformUpTheTurn())},            { "Russian Roulette",() => StartCoroutine(PerformRussianRoulette())},            { "Laugh",() => StartCoroutine(PerformLaugh())},            { "Fixed Shot",() => StartCoroutine(PerformFixedShot())},            { "Cheer Up",() => StartCoroutine(PerformCheerUp())},            { "Braindead Play",() => StartCoroutine(PerformBraindead())},            { "Woroh's Sword",() => StartCoroutine(PerformSword())},            { "Asu's Revenge",() => StartCoroutine(PerformRevenge())},            { "Let's Do It Again",() => StartCoroutine(PerformAgain())},            { "Streaming Heart",() => StartCoroutine(PerformHeart())},            { "Unhappy Refrain",() => StartCoroutine(PerformRefrain())},            { "Levan Polkka",() => StartCoroutine(PerformLevanPolkka())},            { "Defend The Queen",() => StartCoroutine(PerformDefend())}        };        if (actionMap.TryGetValue(usingSkill.skillName, out Action action))        {            attacking.currentMana -= usingSkill.skillManaDrain;            action();        }        else        {            print(usingSkill.skillName + " Nieprawidłowe wykonanie");        }    }    private bool Roll(CharactersParameters chanceOf, string type, int mod = 0)    {        int chance;        if (type == "dodge")        {            chance = chanceOf.currentDodgeChance + mod;            foreach (EffectDetails effect in attacking.effects.FindAll(effect => effect.effectName == "Shattered"))            {                chance += 15;            }            foreach (EffectDetails effect in chanceOf.effects.FindAll(effect => effect.effectName == "Sorrow"))            {                chance -= 15;            }            if (chanceOf.effects.Exists(e => e.effectName == "Braindead"))
            {
                chance = 0;
            }        }        else        {            chance = chanceOf.currentCritChance + mod;            foreach (EffectDetails effect in chanceOf.effects.FindAll(effect => effect.effectName == "Cheered"))            {                chance += 20;            }            if(chanceOf.effects.Exists(e => e.effectName == "Braindead"))
            {
                chance = 0;
            }        }        return UnityEngine.Random.Range(1, 101) <= chance;    }    private int GetDmg(bool isCrit, int value, int valueRange, float multiplier = 1.5f)    {        int startValue;        if (value - valueRange < 0)        {            startValue = 1;        }        else        {            startValue = value - valueRange;        }        int dmg = UnityEngine.Random.Range(startValue, value + valueRange + 1);        if (isCrit)        {            dmg = Mathf.RoundToInt(dmg * multiplier);        }        return dmg;    }    private GameObject CreateExplosion(string path, CharactersParameters target)    {        GameObject explosion = Instantiate(Resources.Load<GameObject>(path));        explosion.GetComponent<ExplosionData>().magicSource = magicAudio;        explosion.transform.position = target.parentTransform.position;        explosion.transform.SetParent(target.parentTransform);        explosion.SetActive(false);        return explosion;    }    private GameObject CreateCast(string path, Vector3 position)    {        GameObject cast = Instantiate(Resources.Load<GameObject>(path));        cast.transform.SetParent(attacking.parentTransform);        AudioClip clip = cast.GetComponent<AudioSource>().clip;        float scale = cast.GetComponent<AudioSource>().volume;        magicAudio.SetNewClip(clip, scale);        cast.transform.position = position;        StartCoroutine(WaitForEnd(cast));        return cast;    }    private GameObject CreateProjectile(string path, Vector3 position, CharactersParameters target, bool isMiss, float additionalRotation = 0)    {        GameObject projectile = Instantiate(Resources.Load<GameObject>(path));        fieldOfView.targets.Add(projectile);        AudioClip clip = projectile.GetComponent<AudioSource>().clip;        float scale = projectile.GetComponent<AudioSource>().volume;        magicAudio.SetNewClip(clip, scale);        projectile.transform.position = position;        ChangeStartRotation(projectile.GetComponent<RectTransform>(), target.charCollider.transform.position, additionalRotation);        projectile.GetComponent<ProjectileFade>().target = target;        projectile.GetComponent<ProjectileFade>().miss = isMiss;        return projectile;    }    private void CreateText(string path, Transform parent, string text, Color color)    {        GameObject obj = Instantiate(Resources.Load<GameObject>(path), parent);        obj.GetComponent<TextMeshPro>().text = text;        VertexGradient gradient;        gradient.bottomLeft = color;        gradient.bottomRight = color;        gradient.topLeft = new Color(1f, 1f, 1f, 1f);        gradient.topRight = new Color(1f, 1f, 1f, 1f);        obj.GetComponent<TextMeshPro>().colorGradient = gradient;        StartCoroutine(WaitForEnd(obj));    }    private IEnumerator WaitForEnd(GameObject obj)    {        yield return new WaitUntil(() => obj.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 1);        if (obj.GetComponent<AudioSource>())        {            magicAudio.clipList.Remove(obj.GetComponent<AudioSource>().clip);        }        Destroy(obj);    }    private void ReceiveMana(CharactersParameters target, int value)    {        if (target.currentMana + value > target.maxMana)        {            target.currentMana = target.maxMana;        }        else        {            target.currentMana += value;        }    }    private void Heal(CharactersParameters target, int damage, bool isCrit, Color color)    {        if (target.currentHP + damage > target.maxHP)        {            target.currentHP = target.maxHP;        }        else        {            target.currentHP += damage;        }        if (isCrit)        {            CreateText("DamageNumbersCrit", target.parentTransform, damage.ToString(), color);        }        else        {            CreateText("DamageNumbers", target.parentTransform, damage.ToString(), color);        }        if (attacking != target)        {            characterAudio.SetNewClip(Resources.Load<AudioClip>("Audio/" + target.name + "/Buff"), target.volumeScale);        }    }    private void Damage(CharactersParameters target, int damage, bool isCrit, Color color)    {        if (damage <= 0)        {            damage = 1;        }        if (!gameFinished)
        {
            target.characterObject.GetComponent<Animator>().SetTrigger("Hit");
            if (target.currentHP - damage <= 0)
            {
                if (target.effects.Exists(effect => effect.effectName == "Plot Armor"))
                {
                    if (attacking != target)
                    {
                        PlayOneAudioFromPath(characterAudio, "Audio/" + target.name + "/Hit", target.volumeScale);
                    }
                    target.currentHP = 1;
                }
                else
                {
                    characterAudio.SetNewClip(Resources.Load<AudioClip>("Audio/" + target.name + "/Death"), target.volumeScale);
                    RemoveCharacter(target);
                    if (charParameters.FindAll(t => !t.IsDead && t.enemy).Count == 1)
                    {
                        StartCoroutine(RemoveEffect(boss.effects.Find(e => e.effectName == "Plot Armor"), boss));
                    }
                    List<CharactersParameters> newtarget = LoadTargets("allEnemies");
                    if (newtarget.Count != 0)
                    {
                        targets = new() { newtarget[UnityEngine.Random.Range(0, newtarget.Count)] };
                    }
                    else
                    {
                        // finish game flag
                    }
                }
            }
            else
            {
                if (attacking != target)
                {
                    PlayOneAudioFromPath(characterAudio, "Audio/" + target.name + "/Hit", target.volumeScale);
                }
                target.currentHP -= damage;
            }
            if (isCrit)
            {
                CreateText("DamageNumbersCrit", target.parentTransform, damage.ToString(), color);
                characterAudio.SetNewClip(Resources.Load<AudioClip>("Audio/" + attacking.name + "/Crit"), attacking.volumeScale);
            }
            else
            {
                CreateText("DamageNumbers", target.parentTransform, damage.ToString(), color);
            }        }    }    private void ReceiveDamage(CharactersParameters target, Color numbersColor, int damage, bool isCrit, bool isDoT = false)    {        if (!isDoT)        {            foreach (EffectDetails eff in attacking.effects.FindAll(effect => effect.effectName == "Cold"))            {                damage = Mathf.FloorToInt(0.70f * damage);            }            if (target.effects.Exists(effect => effect.effectName == "Provocation"))            {                damage = Mathf.FloorToInt(0.65f * damage);            }            foreach (EffectDetails eff in attacking.effects.FindAll(effect => effect.effectName == "Cheered"))            {                damage = Mathf.FloorToInt(damage / 0.85f);            }            if(target.effects.Exists(effect => effect.effectName == "Contra")
                && attacking.effects.FindAll(effect => effect.effectName == "Bleed").Count < 3)
            {
                ReceiveEffect(new("Bleed", 2, "efforange", "EffectsTexture/Bleed Texture", attacking, 8, 2), false);
            }            foreach (EffectDetails eff in target.effects.FindAll(effect => effect.effectName == "Targeted"))            {                damage = Mathf.FloorToInt(damage / 0.75f);            }        }        if (target.effects.Exists(effect => effect.effectName == "Shield"))        {            EffectDetails effect = target.effects.Find(effect => effect.effectName == "Shield");            if (damage <= effect.effectValue)            {                effect.effectValue -= damage;                if (effect.effectValue == 0)                {                    StartCoroutine(RemoveEffect(effect, target));                }                CreateText("DamageInfo", target.parentTransform, "shielded", numbersColor);            }            else            {                damage -= effect.effectValue;                StartCoroutine(RemoveEffect(effect, target));                Damage(target, damage, isCrit, numbersColor);            }        }        else        {            Damage(target, damage, isCrit, numbersColor);        }    }    private void ReceiveEffect(EffectDetails effect, bool isBuff)    {        GameObject obj = Instantiate(Resources.Load<GameObject>("EffectPrefab"), effect.effectParent.effectPanel.transform);        obj.name = effect.effectName;        effect.effectObject = obj;        effect.effectParent.effects.Add(effect);        obj.transform.Find("Mask").transform.Find("Image").GetComponent<Image>().sprite = Resources.Load<Sprite>(effect.effectBackgroundPath);        obj.transform.Find("Frame").GetComponent<Image>().sprite = Resources.Load<Sprite>("EffectsTexture/" + effect.effectFramePath);        obj.GetComponent<EffectsMoveOnBar>().target = effect.effectParent;        Transform desc = obj.transform.Find("Description");        desc.Find("EffectName").Find("Text").GetComponent<TextMeshProUGUI>().text = effect.effectName;        desc.Find("EffectName").Find("Text").GetComponent<TextMeshProUGUI>().fontMaterial = LoadPath(effect.effectFramePath);        desc.Find("DescriptionText").Find("Text").GetComponent<TextMeshProUGUI>().text = effect.effectDesc;        if (effect.effectDuration > 100)        {            desc.Find("EffectDuration").gameObject.SetActive(false);        }        else        {            desc.Find("EffectDuration").Find("Number").GetComponent<TextMeshProUGUI>().text = effect.effectDuration.ToString();        }        if (isBuff && effect.effectParent != attacking)        {            characterAudio.SetNewClip(Resources.Load<AudioClip>("Audio/" + effect.effectParent.name + "/Buff"), effect.effectParent.volumeScale);        }    }    private IEnumerator RemoveEffect(EffectDetails obj, CharactersParameters target)    {        yield return new WaitForFixedUpdate();        if (obj.effectObject.activeSelf)        {            obj.effectObject.GetComponent<Animator>().SetTrigger("Hide");            target.effects.Remove(obj);            yield return new WaitUntil(() => obj.effectObject.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).IsName("EffectHide"));            yield return new WaitUntil(() => obj.effectObject.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 1);        }        Destroy(obj.effectObject);        obj = null;    }    private IEnumerator CheckForMiss(bool isMiss, GameObject explosion, CharactersParameters target, Color color, GameObject projectile, float moveSpeed, int dmg, bool isCrit, float additionalRotation = 0f)    {        if (target.IsDead)        {            isMiss = true;        }        if (!isMiss)        {            if (target.effects.Exists(e => e.effectName == "Shield"))            {                Destroy(explosion);                explosion = CreateExplosion("BuffPrefab/ShieldHit", target);            }            explosion.SetActive(true);            StartCoroutine(WaitForEnd(explosion));            yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);            ReceiveDamage(target, color, dmg, isCrit);            yield return new WaitUntil(() => explosion == null);            Destroy(projectile);        }        else        {            Destroy(explosion);            CreateText("DamageInfo", target.parentTransform, "miss", color);            Vector3 direction = Quaternion.Euler(0, 0, 90f - additionalRotation) * -projectile.transform.up.normalized;            while (projectile.GetComponentsInChildren<Renderer>().Any(renderer => renderer.isVisible) && (projectile.GetComponentsInChildren<SpriteRenderer>().Any(r => r.color.a >= 0.05f) || projectile.GetComponentsInChildren<Image>().Any(r => r.color.a >= 0.05f)))            {                projectile.transform.position += moveSpeed * Time.deltaTime * direction;                foreach (SpriteRenderer ren in projectile.GetComponentsInChildren<SpriteRenderer>().Where(r => r.color.a >= 0.05f))                {                    Color c = ren.color;                    ren.color = new(c.r, c.g, c.b, c.a - Time.deltaTime * 3);                }                foreach (Image img in projectile.GetComponentsInChildren<Image>().Where(r => r.color.a >= 0.05f))                {                    Color c = img.color;                    img.color = new(c.r, c.g, c.b, c.a - Time.deltaTime * 3);                }                yield return new WaitForFixedUpdate();            }            Destroy(projectile);        }    }    private void PlayOneAudioFromPath(AudioHandle source, string path, float scale)    {        AudioClip[] clips = Resources.LoadAll<AudioClip>(path);        source.SetNewClip(clips[UnityEngine.Random.Range(0, clips.Length)], scale);    }    private Material LoadPath(string frame)    {        Material mat = null;        if (frame == "effblue")        {            mat = Resources.Load<Material>("Materials/EffectBlueMaterial");        }        else if (frame == "effblue2")        {            mat = Resources.Load<Material>("Materials/EffectBlue2Material");        }        else if (frame == "effgreen")        {            mat = Resources.Load<Material>("Materials/EffectGreenMaterial");        }        else if (frame == "efforange")        {            mat = Resources.Load<Material>("Materials/EffectOrangeMaterial");        }        else if (frame == "effpurpblue")        {            mat = Resources.Load<Material>("Materials/EffectPurpleBlueMaterial");        }        else if (frame == "effpurple")        {            mat = Resources.Load<Material>("Materials/EffectPurpleMaterial");        }        return mat;    }    private void MoveAndRotateTowards(Vector3 towardsPosition, Transform objTransform, float rotationSpeed, float moveSpeed, float additionalRotation = 0)    {        Vector3 targetDirection = towardsPosition - objTransform.position;        float targetAngle = Mathf.Atan2(targetDirection.y, targetDirection.x) * Mathf.Rad2Deg;        targetAngle += additionalRotation;        Quaternion targetRotation = Quaternion.Euler(0, 0, targetAngle);        objTransform.rotation = Quaternion.RotateTowards(objTransform.rotation, targetRotation, rotationSpeed * Time.deltaTime);        objTransform.position = Vector3.MoveTowards(objTransform.position, towardsPosition, moveSpeed * Time.deltaTime);    }    private void ChangeStartPosition(GameObject obj, float x, float y)    {        Vector2 newPos = obj.GetComponent<RectTransform>().anchoredPosition;        newPos.x += x;        newPos.y += y;        obj.GetComponent<RectTransform>().anchoredPosition = newPos;        try        {            obj.GetComponent<ProjectileFade>().startPosition = newPos;        }        catch { }    }    private void ChangeStartRotation(RectTransform transform, Vector3 towards, float additionalRotation = 0)    {        Vector3 targetDirection = towards - transform.position;        float targetAngleZ = Mathf.Atan2(targetDirection.y, targetDirection.x) * Mathf.Rad2Deg;        targetAngleZ += additionalRotation;        transform.rotation = Quaternion.Euler(0, 0, targetAngleZ);    }    // Source code of every skill    private IEnumerator PerformIceCone()    {        GameObject cast = CreateCast("CastPrefab/IceCast", attacking.parentTransform.position);        GameObject explosion = CreateExplosion("ExplosionPrefab/IceCone", targets[0]);        bool isCrit = Roll(attacking, "crit");        int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);        yield return new WaitUntil(() => cast.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.5f);        explosion.SetActive(true);        yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);        ReceiveDamage(targets[0], new(0f, 0.4f, 1f, 1f), dmg, isCrit);        ReceiveEffect(new("Stun", 1, "efforange", "EffectsTexture/Stun Texture", targets[0]), false);        yield return new WaitUntil(() => explosion.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 1);        Destroy(explosion);        actionPerformed = true;    }    private IEnumerator PerformSnowball()    {        GameObject cast = CreateCast("CastPrefab/IceCast", attacking.parentTransform.position);        GameObject explosion = CreateExplosion("ExplosionPrefab/ExplosionIceCloud", targets[0]);        bool isMiss = Roll(targets[0], "dodge");        bool isCrit = Roll(attacking, "crit");        int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);        GameObject projectile = CreateProjectile("ProjectilePrefab/FireBallBlue", attacking.parentTransform.position, targets[0], isMiss);        float rotationSpeed = 360, moveSpeed = 2;        while (!projectile.GetComponent<ProjectileFade>().hit)        {            MoveAndRotateTowards(targets[0].charCollider.transform.position, projectile.transform, rotationSpeed, moveSpeed);            moveSpeed++;            yield return new WaitForFixedUpdate();        }        StartCoroutine(CheckForMiss(isMiss, explosion, targets[0], new(0f, 0.4f, 1f, 1f), projectile, moveSpeed, dmg, isCrit));        yield return new WaitUntil(() => projectile == null || (explosion != null && explosion.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.7f));        actionPerformed = true;    }    private IEnumerator PerformSolidIce()    {        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        GameObject explosion = CreateExplosion("BuffPrefab/Shield", targets[0]);        yield return new WaitUntil(() => cast.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.5f);        explosion.SetActive(true);        yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);        if (attacking.effects.Exists(effect => effect.effectName == "Shield"))        {            StartCoroutine(RemoveEffect(attacking.effects.Find(effect => effect.effectName == "Shield"), attacking));        }        ReceiveEffect(new EffectDetails("Shield", 999, "effblue",            "EffectsTexture/Shield Texture", targets[0], GetDmg(false, usingSkill.skillValue, usingSkill.skillValueRange)), true);        yield return new WaitUntil(() => explosion.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 1);        Destroy(explosion);        actionPerformed = true;    }    private IEnumerator PerformFreezingGun()    {        float rotationSpeed = 360, moveSpeed = 30;        IEnumerator MoveProjectile(GameObject projectile, CharactersParameters target, bool isMiss, GameObject explosion)        {            bool isCrit = Roll(attacking, "crit");            int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);            while (!projectile.GetComponent<ProjectileFade>().hit)            {                MoveAndRotateTowards(target.charCollider.transform.position, projectile.transform, rotationSpeed, moveSpeed);                yield return new WaitForFixedUpdate();            }            StartCoroutine(CheckForMiss(isMiss, explosion, target, new(0.7f, 1f, 0.9f, 1f), projectile, moveSpeed, dmg, isCrit));        }        List<GameObject> explosions = new();        List<GameObject> projectiles = new();        for (int i = 0; i < 7; i++)        {            GameObject cast = CreateCast("CastPrefab/FreezingGun", attacking.parentTransform.position);            float x = UnityEngine.Random.Range(-0.5f, 0.5f), y = UnityEngine.Random.Range(-0.5f, 0.5f);            CharactersParameters target = targets[UnityEngine.Random.Range(0, targets.Count)];            ChangeStartPosition(cast, x, y);            explosions.Add(CreateExplosion("ExplosionPrefab/ExplosionBulletBlue", target));            bool isMiss = Roll(targets[0], "dodge");            projectiles.Add(CreateProjectile("ProjectilePrefab/BulletProjectileBlue", attacking.parentTransform.position, target, isMiss));            projectiles[i].GetComponent<Image>().sprite = Resources.Load<Sprite>("Sprites/Projectile/Bullets/07");            ChangeStartPosition(projectiles[i], x, y);            StartCoroutine(MoveProjectile(projectiles[i], target, isMiss, explosions[i]));            yield return new WaitForSecondsRealtime(0.2f);        }        for (int i = 0; i < 7; i++)        {            yield return new WaitUntil(() => projectiles[i].gameObject == null || projectiles[i].gameObject is null);        }        actionPerformed = true;    }    private IEnumerator PerformShatteredIce()    {        GameObject cast = CreateCast("CastPrefab/IceCast", attacking.parentTransform.position);        GameObject explosion = CreateExplosion("ExplosionPrefab/IceShatter", targets[0]);        yield return new WaitUntil(() => cast.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.5f);        explosion.SetActive(true);        yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);        ReceiveEffect(new EffectDetails("Shattered", 4, "effblue2", "EffectsTexture/Shatter Texture", targets[0]), false);        StartCoroutine(WaitForEnd(explosion));        actionPerformed = true;    }    private IEnumerator PerformIceWallow()    {        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        List<GameObject> explosions = new();        for (int i = 0; i < targets.Count; i++)        {            explosions.Add(CreateExplosion("ExplosionPrefab/IceWallow", targets[i]));            StartCoroutine(WaitForEnd(explosions[i]));            explosions[i].SetActive(true);            ReceiveEffect(new EffectDetails("Unfreeze", 3, "effgreen", "EffectsTexture/Unfreeze Texture", targets[i], 120, 15), true);            yield return new WaitForSeconds(0.5f);        }        GameObject nextExplosion = CreateExplosion("ExplosionPrefab/IceCone", attacking);        nextExplosion.SetActive(true);        StartCoroutine(WaitForEnd(nextExplosion));        yield return new WaitUntil(() => nextExplosion.GetComponent<ExplosionData>().explode);        ReceiveEffect(new EffectDetails("Stun", 2, "efforange", "EffectsTexture/Stun Texture", attacking), false);        yield return new WaitUntil(() => nextExplosion.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 1);        actionPerformed = true;    }    private IEnumerator PerformBloodFreeze()    {        float rotationSpeed = 360, moveSpeed = 15, additionalRotation = 180;        IEnumerator MoveProjectile(GameObject projectile, CharactersParameters target, bool isMiss, GameObject explosion)        {            bool isCrit = Roll(attacking, "crit");            int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);            float distance = Mathf.Abs((projectile.transform.position.x - target.charCollider.transform.position.x) / 2);            while (!projectile.GetComponent<ProjectileFade>().hit)            {                MoveAndRotateTowards(target.charCollider.transform.position, projectile.transform, rotationSpeed, moveSpeed, additionalRotation);                yield return new WaitForFixedUpdate();            }            if (target.effects.Exists(effect => effect.effectName == "Shattered") && !isMiss)            {                ReceiveEffect(new EffectDetails("Cold", 4, "effpurpblue", "EffectsTexture/Cold Texture", target), false);            }            StartCoroutine(CheckForMiss(isMiss, explosion, target, new(0.15f, 0.63f, 1f, 1f), projectile, moveSpeed, dmg, isCrit, additionalRotation));        }        GameObject cast = CreateCast("CastPrefab/IceCast", attacking.parentTransform.position);        List<GameObject> explosions = new();        List<GameObject> projectiles = new();        for (int i = 0; i < targets.Count; i++)        {            explosions.Add(CreateExplosion("ExplosionPrefab/BloodFreeze", targets[i]));            bool isMiss = Roll(targets[i], "dodge");            projectiles.Add(CreateProjectile("ProjectilePrefab/IceProjectile", attacking.parentTransform.position, targets[i], isMiss, additionalRotation));            StartCoroutine(MoveProjectile(projectiles[i], targets[i], isMiss, explosions[i]));        }        yield return new WaitUntil(() => projectiles[^1] == null);        actionPerformed = true;    }    private IEnumerator PerformSlipAndSlide()    {        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        GameObject explosion = CreateExplosion("ExplosionPrefab/ExplosionIceCloud", targets[0]);        bool isMiss = Roll(targets[0], "dodge");        bool isCrit = Roll(attacking, "crit");        int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);        GameObject projectile = CreateProjectile("ProjectilePrefab/WarpPortalBlue", attacking.parentTransform.position, targets[0], isMiss);        projectile.GetComponent<Image>().color = new(0.6f, 0.57f, 1f, 0f);        float rotationSpeed = 360, moveSpeed = 3;        while (!projectile.GetComponent<ProjectileFade>().hit)        {            MoveAndRotateTowards(targets[0].charCollider.transform.position, projectile.transform, rotationSpeed, moveSpeed);            moveSpeed++;            yield return new WaitForFixedUpdate();        }        StartCoroutine(CheckForMiss(isMiss, explosion, targets[0], new(0.6f, 0.57f, 1f, 1f), projectile, moveSpeed, dmg, isCrit));        if (!isMiss)        {            ReceiveEffect(new("Slowed Down", 2, "efforange", "EffectsTexture/Slowed Texture", targets[0], 35, 2), false);        }        yield return new WaitUntil(() => projectile == null || (explosion != null && explosion.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.7f));        actionPerformed = true;    }    private IEnumerator PerformGachaAddict()    {        bool isPass = false;        IEnumerator RegenMana()        {            CreateText("DamageInfo", attacking.parentTransform, "mana regen", new(0f, 0.5f, 1f, 1f));            GameObject explosion = CreateExplosion("BuffPrefab/ManaRegen", attacking);            explosion.SetActive(true);            yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);            attacking.currentMana = attacking.maxMana;            yield return new WaitUntil(() => explosion.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 1f);            Destroy(explosion);            isPass = true;        }        IEnumerator GachaHeal()        {            targets = LoadTargets("ally");            CreateText("DamageInfo", attacking.parentTransform, "heal", new(0f, 1f, 0.2f, 1f));            StartCoroutine(PlayerPickSpecificTarget("ally"));            yield return new WaitUntil(() => GetComponent<OutlineHandler>().confirmed != null);            targets = new()
            {
                GetComponent<OutlineHandler>().confirmed
            };            bool isCrit = Roll(attacking, "crit");            int heal = GetDmg(isCrit, 50, 5);            GameObject explosion = CreateExplosion("BuffPrefab/Heal", targets[0]);            explosion.SetActive(true);            yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);            Heal(targets[0], heal, isCrit, new(0f, 1f, 0.2f, 1f));            yield return new WaitUntil(() => explosion.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 1f);            Destroy(explosion);            isPass = true;        }        IEnumerator Attack(bool isCrit)        {            GameObject cast = CreateCast("CastPrefab/YellowSphere", attacking.parentTransform.position);            ChangeStartRotation(cast.GetComponent<RectTransform>(), cast.GetComponent<RectTransform>().position, 180);            bool isMiss = Roll(targets[0], "dodge");            int damage = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);            GameObject explosion = CreateExplosion("ExplosionPrefab/YellowBlink", targets[0]);            GameObject projectile = CreateProjectile("ProjectilePrefab/WarpPortalYellow", attacking.parentTransform.position, targets[0], isMiss);            float rotationSpeed = 360, moveSpeed = 6;            while (!projectile.GetComponent<ProjectileFade>().hit)            {                MoveAndRotateTowards(targets[0].charCollider.transform.position, projectile.transform, rotationSpeed, moveSpeed);                moveSpeed++;                yield return new WaitForFixedUpdate();            }            StartCoroutine(CheckForMiss(isMiss, explosion, targets[0], new(1f, 0.631f, 0f, 1f), projectile, moveSpeed, damage, isCrit));            isPass = true;            yield return new WaitUntil(() => projectile == null);        }        IEnumerator Failed()        {            CreateText("DamageInfo", attacking.parentTransform, "failed", new(1f, 0f, 0f, 1f));            yield return new WaitForSeconds(1);            isPass = true;        }        GameObject cast = CreateCast("CastPrefab/Gacha", attacking.parentTransform.position);        yield return new WaitUntil(() => cast.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.7f);        int number = UnityEngine.Random.Range(1, 101);        //15 %: przywrócenie sobie całej many\n15 %: przywrócenie komuś do 70 HP\n10 %: CRIT 4x hit   25 %: 2x hit   25 %: 1x hit\n10 %: niewypał"        if (number >= 1 && number < 15)        {            StartCoroutine(RegenMana());        }        else if (number >= 15 && number < 30)        {            StartCoroutine(GachaHeal());        }        else if (number >= 30 && number < 40)        {            CreateText("DamageInfo", attacking.parentTransform, "4x crit", new(1f, 0.631f, 0f, 1f));            targets = LoadTargets("enemy");            if (targets.Count != 1)            {                StartCoroutine(PlayerPickSpecificTarget("enemy"));                yield return new WaitUntil(() => GetComponent<OutlineHandler>().confirmed != null);                targets = new()                {                    GetComponent<OutlineHandler>().confirmed                };            }            for (int i = 0; i < 4; i++)            {                isPass = false;                StartCoroutine(Attack(true));                yield return new WaitUntil(() => isPass);            }        }        else if (number >= 40 && number < 65)        {            CreateText("DamageInfo", attacking.parentTransform, "2x attack", new(1f, 0.631f, 0f, 1f));            targets = LoadTargets("enemy");            if (targets.Count != 1)            {                StartCoroutine(PlayerPickSpecificTarget("enemy"));                yield return new WaitUntil(() => GetComponent<OutlineHandler>().confirmed != null);                targets = new()                {                    GetComponent<OutlineHandler>().confirmed                };            }            for (int i = 0; i < 2; i++)            {                isPass = false;                bool isCrit = Roll(attacking, "crit");                StartCoroutine(Attack(isCrit));                yield return new WaitUntil(() => isPass);            }        }        else if (number >= 65 && number < 90)        {            CreateText("DamageInfo", attacking.parentTransform, "1x attack", new(1f, 0.631f, 0f, 1f));            targets = LoadTargets("enemy");            if (targets.Count != 1)            {                StartCoroutine(PlayerPickSpecificTarget("enemy"));                yield return new WaitUntil(() => GetComponent<OutlineHandler>().confirmed != null);                targets = new()                {                    GetComponent<OutlineHandler>().confirmed                };            }            bool isCrit = Roll(attacking, "crit");            StartCoroutine(Attack(isCrit));        }        else        {            StartCoroutine(Failed());        }        yield return new WaitUntil(() => isPass);        yield return new WaitForSeconds(0.5f);        actionPerformed = true;    }    private IEnumerator PerformFriendship()    {        float clipLength = 0;        IEnumerator ReceiveRepeat(CharactersParameters target)        {            GameObject explosion = CreateExplosion("ExplosionPrefab/Repeat", target);            explosion.SetActive(true);            StartCoroutine(WaitForEnd(explosion));            clipLength = explosion.GetComponent<AudioSource>().clip.length;            yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);            ReceiveEffect(new("Repeat", 1, "effgreen", "EffectsTexture/Repeat Texture", target), true);            yield return new WaitUntil(() => explosion == null);        }        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        yield return new WaitUntil(() => cast.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.6f);        for (int i = 0; i < targets.Count; i++)        {            if (targets[i] != attacking)            {                StartCoroutine(ReceiveRepeat(targets[i]));                yield return new WaitForFixedUpdate();            }        }        yield return new WaitForSeconds(clipLength);        GameObject explosion = CreateExplosion("ExplosionPrefab/Thunder", attacking);        explosion.SetActive(true);        StartCoroutine(WaitForEnd(explosion));        yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);        ReceiveEffect(new("Stun", 2, "efforange", "EffectsTexture/Stun Texture", attacking), false);        actionPerformed = true;    }    private IEnumerator PerformKilljoy()    {        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        GameObject explosion = CreateExplosion("BuffPrefab/Killjoy", targets[0]);        yield return new WaitUntil(() => cast.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.6f);        explosion.SetActive(true);        StartCoroutine(WaitForEnd(explosion));        yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);        ReceiveEffect(new("Contra", 3, "effpurpblue", "EffectsTexture/Contra Texture", attacking), true);        ReceiveEffect(new("Provocation", 2, "effblue2", "EffectsTexture/Provocation Texture", attacking), true);        actionPerformed = true;    }    private IEnumerator PerformHighPing()    {        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        GameObject explosion = CreateExplosion("BuffPrefab/Ping", targets[0]);        yield return new WaitUntil(() => cast.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.6f);        explosion.SetActive(true);        StartCoroutine(WaitForEnd(explosion));        yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);        ReceiveEffect(new("Sped Up", 3, "effgreen", "EffectsTexture/Sped Texture", targets[0], -50, 3), true);        actionPerformed = true;    }    private IEnumerator PerformCuteness()    {        GameObject cast = CreateCast("CastPrefab/CuteCast", attacking.parentTransform.position);        GameObject explosion = CreateExplosion("ExplosionPrefab/CuteExplosion", targets[0]);        bool isMiss = Roll(targets[0], "dodge");        GameObject projectile = CreateProjectile("ProjectilePrefab/CuteProjectile", attacking.parentTransform.position, targets[0], isMiss);        float rotationSpeed = 360, moveSpeed = 6;        while (!projectile.GetComponent<ProjectileFade>().hit)        {            MoveAndRotateTowards(targets[0].parentTransform.position, projectile.transform, rotationSpeed, moveSpeed);            moveSpeed++;            yield return new WaitForFixedUpdate();        }        bool isCrit = Roll(attacking, "crit");        int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);        StartCoroutine(CheckForMiss(isMiss, explosion, targets[0], new(1f, 0.4f, 1f, 1f), projectile, moveSpeed, dmg, isCrit));        yield return new WaitUntil(() => projectile == null);        actionPerformed = true;    }    private IEnumerator PerformAce()    {        float rotationSpeed = 360, moveSpeed = 30;        IEnumerator MoveProjectile(GameObject projectile, CharactersParameters target, bool isMiss, GameObject explosion)        {            bool isCrit = Roll(attacking, "crit");            int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);            while (!projectile.GetComponent<ProjectileFade>().hit)            {                MoveAndRotateTowards(target.charCollider.transform.position, projectile.transform, rotationSpeed, moveSpeed);                yield return new WaitForFixedUpdate();            }            StartCoroutine(CheckForMiss(isMiss, explosion, target, new(1f, 0.6f, 0f, 1f), projectile, moveSpeed, dmg, isCrit));        }        List<GameObject> casts = new();        List<GameObject> explosions = new();        List<GameObject> projectiles = new();        for (int i = 0; i < 5; i++)        {            casts.Add(CreateCast("CastPrefab/BulletCastOrange", attacking.parentTransform.position));            ChangeStartPosition(casts[i], 1.7f, -1.2f);            CharactersParameters target = targets[UnityEngine.Random.Range(0, targets.Count)];            explosions.Add(CreateExplosion("ExplosionPrefab/ExplosionBulletOrange", target));            bool isMiss = Roll(target, "dodge");            projectiles.Add(CreateProjectile("ProjectilePrefab/BulletProjectile", attacking.parentTransform.position, target, isMiss));            ChangeStartPosition(projectiles[i], 1.2f, -1.2f);            projectiles[i].GetComponent<Image>().sprite = Resources.Load<Sprite>("Sprites/Projectile/Bullets/19");            StartCoroutine(MoveProjectile(projectiles[i], target, isMiss, explosions[i]));            magicAudio.clipList.Remove(casts[i].GetComponent<AudioSource>().clip);            yield return new WaitForSecondsRealtime(0.5f);        }        for (int i = 0; i < 5; i++)        {            yield return new WaitUntil(() => projectiles[i].gameObject == null || gameObject is null);        }        actionPerformed = true;    }    private IEnumerator PerformShotgun()    {        float rotationSpeed = 360, moveSpeed = 35;        IEnumerator MoveProjectile(GameObject projectile, CharactersParameters target, GameObject explosion)        {            bool isMiss = Roll(target, "dodge");            projectile.GetComponent<ProjectileFade>().miss = isMiss;            while (!projectile.GetComponent<ProjectileFade>().hit)            {                MoveAndRotateTowards(target.parentTransform.position, projectile.transform, rotationSpeed, moveSpeed);                yield return new WaitForFixedUpdate();            }            bool isCrit = Roll(attacking, "crit");            int damage = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);            if (target != targets[0])            {                damage = Mathf.CeilToInt(damage * 0.25f);            }            StartCoroutine(CheckForMiss(isMiss, explosion, target, new(0.859f, 0.502f, 0f, 1f), projectile, moveSpeed, damage, isCrit));        }        List<CharactersParameters> targetsHolder = new(targets);        List<GameObject> explosions = new();        List<GameObject> projectiles = new();        if (attacking.enemy)        {            targets = new();            targets.Add(targetsHolder[UnityEngine.Random.Range(0, targets.Count)]);        }        else if (targets.Count != 1)        {            StartCoroutine(PlayerPickSpecificTarget("enemy"));            yield return new WaitUntil(() => GetComponent<OutlineHandler>().confirmed != null);            targets = new()            {                GetComponent<OutlineHandler>().confirmed            };        }        GameObject cast = CreateCast("CastPrefab/ShotgunShot", attacking.parentTransform.position);        for (int i = 0; i < targetsHolder.Count; i++)        {            explosions.Add(CreateExplosion("ExplosionPrefab/Shotgun", targetsHolder[i]));            if (targetsHolder[i] == targets[0])            {                projectiles.Add(CreateProjectile("ProjectilePrefab/ShotgunPrime", attacking.parentTransform.position, targetsHolder[i], false));            }            else            {                projectiles.Add(CreateProjectile("ProjectilePrefab/ShotgunSmall", attacking.parentTransform.position, targetsHolder[i], false));            }            StartCoroutine(MoveProjectile(projectiles[i], targetsHolder[i], explosions[i]));        }        for (int i = 0; i < targetsHolder.Count; i++)        {            yield return new WaitUntil(() => projectiles[i] == null);        }        actionPerformed = true;    }    private IEnumerator PerformPreciseShot()    {        GameObject cast = CreateCast("CastPrefab/ShotgunShot", attacking.parentTransform.position);        GameObject explosion = CreateExplosion("ExplosionPrefab/Shotgun", targets[0]);        bool isMiss = Roll(targets[0], "dodge");        GameObject projectile = CreateProjectile("ProjectilePrefab/ShotgunPrime", attacking.parentTransform.position, targets[0], isMiss);        float rotationSpeed = 360, moveSpeed = 25;        while (!projectile.GetComponent<ProjectileFade>().hit)        {            MoveAndRotateTowards(targets[0].parentTransform.position, projectile.transform, rotationSpeed, moveSpeed);            yield return new WaitForFixedUpdate();        }        bool isCrit = Roll(attacking, "crit", 35);        int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange, 2);        StartCoroutine(CheckForMiss(isMiss, explosion, targets[0], new(0.859f, 0.502f, 0f, 1f), projectile, moveSpeed, dmg, isCrit));        yield return new WaitUntil(() => projectile == null);        actionPerformed = true;    }    private IEnumerator PerformTarget()    {        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        GameObject explosion = CreateExplosion("BuffPrefab/Cauterize", targets[0]);        yield return new WaitUntil(() => cast.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.6f);        explosion.SetActive(true);        StartCoroutine(WaitForEnd(explosion));        yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);        ReceiveEffect(new("Targeted", 2, "efforange", "EffectsTexture/Targeted Texture", targets[0]), false);        actionPerformed = true;    }    private IEnumerator PerformDefend()    {        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        GameObject explosion = CreateExplosion("BuffPrefab/BlueBuff", targets[0]);        yield return new WaitUntil(() => cast.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.6f);        explosion.SetActive(true);        StartCoroutine(WaitForEnd(explosion));        yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);        ReceiveEffect(new("Provocation", 3, "effblue2", "EffectsTexture/Provocation Texture", targets[0]), true);        actionPerformed = true;    }    private IEnumerator PerformKnifeStab()    {        float additionalRotation = 90f;        GameObject explosion = CreateExplosion("ExplosionPrefab/Knife", targets[0]);        bool isMiss = Roll(targets[0], "dodge");        GameObject projectile = CreateProjectile("ProjectilePrefab/Knife", attacking.parentTransform.position, targets[0], isMiss, additionalRotation);        float rotationSpeed = 360, moveSpeed = 6;        while (!projectile.GetComponent<ProjectileFade>().hit)        {            MoveAndRotateTowards(targets[0].parentTransform.position, projectile.transform, rotationSpeed, moveSpeed, additionalRotation);            moveSpeed++;            yield return new WaitForFixedUpdate();        }        bool isCrit = Roll(attacking, "crit");        int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);        StartCoroutine(CheckForMiss(isMiss, explosion, targets[0], new(1f, 0f, 0.1f, 1f), projectile, moveSpeed, dmg, isCrit, additionalRotation));        yield return new WaitUntil(() => projectile == null);        actionPerformed = true;    }    private IEnumerator PerformFireDragon()    {        float rotationSpeed = 0, moveSpeed = 9f, additionalRotation = 0;        IEnumerator CheckForMissLite(CharactersParameters target)        {            Color color = new(0f, 0.8f, 1f, 1f);            bool isMiss = Roll(target, "dodge");            if (!isMiss)            {                GameObject explosion = CreateExplosion("ExplosionPrefab/BlueFire", target);                explosion.SetActive(true);                StartCoroutine(WaitForEnd(explosion));                bool isCrit = Roll(attacking, "crit");                int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);                yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);                ReceiveDamage(target, color, dmg, isCrit);            }            else            {                CreateText("DamageInfo", target.parentTransform, "miss", color);            }        }        CharactersParameters GetTarget(bool lowest = true)        {            CharactersParameters returnedTarget = targets[0];            foreach (CharactersParameters singleTarget in targets)            {                if (lowest)                {                    if (singleTarget.parentTransform.position.y < returnedTarget.parentTransform.position.y)                    {                        returnedTarget = singleTarget;                    }                }                else                {                    if (singleTarget.parentTransform.position.y > returnedTarget.parentTransform.position.y)                    {                        returnedTarget = singleTarget;                    }                }            }            return returnedTarget;        }        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        CharactersParameters newTarget = GetTarget(false);        GameObject projectile = CreateProjectile("ProjectilePrefab/FireDragon", attacking.parentTransform.position, newTarget, false, additionalRotation);        ChangeStartPosition(projectile, 0, 6);        ChangeStartRotation(projectile.GetComponent<RectTransform>(), newTarget.charCollider.transform.position);        while (targets.Count != 0)        {            if (rotationSpeed < 750)            {                rotationSpeed += 80;            }            Vector3 targetDirection = newTarget.parentTransform.position - projectile.transform.position;            float targetAngle = Mathf.Atan2(targetDirection.y, targetDirection.x) * Mathf.Rad2Deg + additionalRotation;            Quaternion targetRotation = Quaternion.Euler(0, 0, targetAngle);            projectile.transform.rotation = Quaternion.RotateTowards(projectile.transform.rotation, targetRotation, rotationSpeed * Time.deltaTime);            projectile.transform.Translate(new(moveSpeed * Time.deltaTime, 0, 0));            if (projectile.GetComponent<ProjectileFade>().hit)            {                rotationSpeed = 400;                StartCoroutine(CheckForMissLite(newTarget));                targets.Remove(newTarget);                if (targets.Count != 0)                {                    newTarget = GetTarget(false);                    projectile.GetComponent<ProjectileFade>().target = newTarget;                    projectile.GetComponent<ProjectileFade>().hit = false;                }            }            yield return new WaitForFixedUpdate();        }        Vector3 direction = Quaternion.Euler(0, 0, 90f) * -projectile.transform.up.normalized;        while (projectile.GetComponent<Renderer>().isVisible && projectile.GetComponentInChildren<Image>().color.a > 0.05f)        {            Color c = projectile.GetComponentInChildren<Image>().color;            c.a -= 0.3f * moveSpeed * Time.deltaTime;            projectile.GetComponentInChildren<Image>().color = c;            projectile.transform.position += moveSpeed * Time.deltaTime * direction;            yield return new WaitForFixedUpdate();        }        Destroy(projectile);        actionPerformed = true;    }    private IEnumerator PerformHack()    {        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        GameObject explosion = CreateExplosion("BuffPrefab/Hack", targets[0]);        explosion.SetActive(true);        StartCoroutine(WaitForEnd(explosion));        yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);        ReceiveEffect(new("Repeat", 3, "effgreen", "EffectsTexture/Repeat Texture", attacking), true);        ReceiveEffect(new("Cheered", 3, "effgreen", "EffectsTexture/Cheered Texture", attacking), true);        actionPerformed = true;    }    private IEnumerator PerformNemesis()    {        float additionalRotation = -90;        GameObject explosion = CreateExplosion("ExplosionPrefab/Fists", targets[0]);        bool isMiss = Roll(targets[0], "dodge");        GameObject projectile = CreateProjectile("ProjectilePrefab/Fist", attacking.parentTransform.position, targets[0], isMiss, additionalRotation);        float rotationSpeed = 360, moveSpeed = 6;        while (!projectile.GetComponent<ProjectileFade>().hit)        {            MoveAndRotateTowards(targets[0].parentTransform.position, projectile.transform, rotationSpeed, moveSpeed, additionalRotation);            moveSpeed++;            yield return new WaitForFixedUpdate();        }        bool isCrit = Roll(attacking, "crit");        int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);        StartCoroutine(CheckForMiss(isMiss, explosion, targets[0], new(1f, 0.7f, 0f, 1f), projectile, moveSpeed, dmg, isCrit, additionalRotation));        yield return new WaitUntil(() => projectile == null);        actionPerformed = true;    }    private IEnumerator PerformInsulinShot()    {        GameObject explosion = CreateExplosion("BuffPrefab/HealInsulin", targets[0]);        explosion.SetActive(true);        StartCoroutine(WaitForEnd(explosion));        yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);        bool isCrit = Roll(attacking, "crit");        Heal(targets[0], GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange, 1.3f), isCrit, new(0f, 1f, 0.35f, 1f));        ReceiveMana(targets[0], GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange, 1.3f));        actionPerformed = true;    }    private IEnumerator PerformRichard()    {        float additionalRotation = 90;        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        GameObject explosion = CreateExplosion("ExplosionPrefab/Blade", targets[0]);        bool isMiss = Roll(targets[0], "dodge");        GameObject projectile = CreateProjectile("ProjectilePrefab/Blade", attacking.parentTransform.position, targets[0], isMiss, additionalRotation);        float rotationSpeed = 360, moveSpeed = 25;        while (!projectile.GetComponent<ProjectileFade>().hit)        {            MoveAndRotateTowards(targets[0].parentTransform.position, projectile.transform, rotationSpeed, moveSpeed, additionalRotation);            yield return new WaitForFixedUpdate();        }        bool isCrit = Roll(attacking, "crit");        int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);        StartCoroutine(CheckForMiss(isMiss, explosion, targets[0], new(1f, 0.1f, 0f, 1f), projectile, moveSpeed, dmg, isCrit, additionalRotation));        yield return new WaitUntil(() => projectile == null);        actionPerformed = true;    }    private IEnumerator PerformSword()    {        IEnumerator CheckForMissLite(CharactersParameters target)        {            Color color = new(1f, 0f, 0f, 1f);            bool isMiss = Roll(target, "dodge");            if (!isMiss)            {                GameObject explosion = CreateExplosion("ExplosionPrefab/Electric", target);                if (target.effects.Exists(e => e.effectName == "Shield"))                {                    Destroy(explosion);                    explosion = CreateExplosion("BuffPrefab/ShieldHit", target);                }                explosion.SetActive(true);                StartCoroutine(WaitForEnd(explosion));                bool isCrit = Roll(attacking, "crit");                int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);                yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);                ReceiveDamage(target, color, dmg, isCrit);                ReceiveEffect(new("Bleed", 3, "efforange", "EffectsTexture/Bleed Texture", target, 8, 2), false);            }            else            {                CreateText("DamageInfo", target.parentTransform, "miss", color);            }        }        CharactersParameters GetHighestTarget()        {            CharactersParameters returnedTarget = targets[0];            foreach (CharactersParameters singleTarget in targets)            {                if (singleTarget.parentTransform.position.y > returnedTarget.parentTransform.position.y)                {                    returnedTarget = singleTarget;                }            }            return returnedTarget;        }        GameObject CreateSword(string path, Vector3 position, CharactersParameters target)        {            GameObject projectile = Instantiate(Resources.Load<GameObject>(path));            projectile.transform.position = position;            projectile.GetComponent<SwordData>().target = target;            return projectile;        }        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        yield return new WaitForSeconds(1f);        GameObject projectile = CreateSword("ProjectilePrefab/Sword", attacking.parentTransform.position, targets[0]);        while (targets.Count != 0)        {            CharactersParameters nowTarget = GetHighestTarget();            projectile.GetComponent<SwordData>().target = nowTarget;            yield return new WaitUntil(() => projectile.GetComponent<SwordData>().hit);            StartCoroutine(CheckForMissLite(nowTarget));            targets.Remove(nowTarget);            projectile.GetComponent<SwordData>().hit = false;        }        yield return new WaitUntil(() => projectile.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 1);        Destroy(projectile);        actionPerformed = true;    }    private IEnumerator PerformGameBug()    {        IEnumerator Explode(GameObject explosion, CharactersParameters target)        {            yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);            bool isCrit = Roll(attacking, "crit");            ReceiveDamage(target, new(0.45f, 0f, 1f, 1f), GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange, 1.1f), isCrit);            int roll = UnityEngine.Random.Range(0, 100);            if (roll >= 0 && roll < 10)            {                ReceiveEffect(new("Respiration", 2, "effgreen", "EffectsTexture/Respiration Texture", target, 15, 10), true);            }            else if (roll >= 20 && roll < 30)            {                ReceiveEffect(new("Bleed", 3, "efforange", "EffectsTexture/Bleed Texture", target, 8, 2), false);            }            else if (roll >= 40 && roll < 50)            {                ReceiveEffect(new("Sorrow", 2, "effblue", "EffectsTexture/Sorrow Texture", target), false);            }            else if (roll >= 60 && roll < 70)            {                ReceiveEffect(new("Slowed Down", 2, "efforange", "EffectsTexture/Slowed Texture", target, 35, 2), false);            }            else if (roll >= 85 && roll < 90)            {                ReceiveEffect(new("Stun", 1, "efforange", "EffectsTexture/Stun Texture", target), false);            }        }        List<GameObject> explosions = new();        for (int i = 0; i < targets.Count; i++)        {            explosions.Add(CreateExplosion("ExplosionPrefab/Void", targets[i]));            explosions[i].SetActive(true);            StartCoroutine(WaitForEnd(explosions[i]));            StartCoroutine(Explode(explosions[i], targets[i]));            yield return new WaitForFixedUpdate();        }        yield return new WaitUntil(() => explosions[^1] == null || explosions[^1].GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 1);        actionPerformed = true;    }    private IEnumerator PerformHair()    {        GameObject explosion = CreateExplosion("ExplosionPrefab/Hair", targets[0]);        bool isMiss = Roll(targets[0], "dodge");        GameObject projectile = CreateProjectile("ProjectilePrefab/ChargedBolt", attacking.parentTransform.position, targets[0], isMiss);        float rotationSpeed = 360, moveSpeed = 25;        while (!projectile.GetComponent<ProjectileFade>().hit)        {            MoveAndRotateTowards(targets[0].parentTransform.position, projectile.transform, rotationSpeed, moveSpeed);            yield return new WaitForFixedUpdate();        }        bool isCrit = Roll(attacking, "crit");        int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);        StartCoroutine(CheckForMiss(isMiss, explosion, targets[0], new(0.5f, 0.25f, 0f, 1f), projectile, moveSpeed, dmg, isCrit));        yield return new WaitUntil(() => projectile == null);        if (!isMiss)        {            ReceiveEffect(new("Slowed Down", 2, "efforange", "EffectsTexture/Slowed Texture", targets[0], 50, 2), false);        }        actionPerformed = true;    }    private IEnumerator PerformUpTheTurn()    {        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        GameObject explosion = CreateExplosion("ExplosionPrefab/Repeat", targets[0]);        explosion.SetActive(true);        StartCoroutine(WaitForEnd(explosion));        yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);        List<TurnID> mrozonTurns = turnAllocation.FindAll(s => s.name == "Mrożon");        int speedDiff = mrozonTurns[0].speed - turnAllocation[0].speed;        mrozonTurns[0].speed = turnAllocation[0].speed;        mrozonTurns.Remove(mrozonTurns[0]);        foreach(TurnID turn in mrozonTurns)
        {
            turn.speed -= speedDiff;
        }        yield return new WaitForSeconds(.5f);        actionPerformed = true;    }    private IEnumerator PerformRussianRoulette()    {        GameObject explosion = CreateExplosion("ExplosionPrefab/Shotgun", attacking);        AudioClip gunClick = Resources.Load<AudioClip>("Audio/Magic/gunCock");        if (!attacking.effects.Exists(effect => effect.effectName == "Game's Begun"))        {            ReceiveEffect(new("Game's Begun", 999, "effpurpblue", "EffectsTexture/Game's Begun Texture", attacking, 6), true);        }        EffectDetails effect = attacking.effects.Find(effect => effect.effectName == "Game's Begun");        bool isHit = UnityEngine.Random.Range(0, effect.effectValue) == 0;        if (isHit)        {            GameObject cast = CreateCast("CastPrefab/ShotgunShot", attacking.parentTransform.position);            explosion.SetActive(true);            StartCoroutine(WaitForEnd(explosion));            ReceiveDamage(attacking, new(1f, 0.6f, 0f, 1f), GetDmg(false, usingSkill.skillValue, usingSkill.skillValueRange), false);            StartCoroutine(RemoveEffect(effect, attacking));        }        else        {            magicAudio.SetNewClip(gunClick, 1f);            yield return new WaitForSeconds(gunClick.length);            effect.effectValue--;            isHit = UnityEngine.Random.Range(0, effect.effectValue) == 0;            if (isHit)            {                GameObject cast = CreateCast("CastPrefab/ShotgunShot", attacking.parentTransform.position);                explosion.transform.position = targets[0].parentTransform.position;                GameObject projectile = CreateProjectile("ProjectilePrefab/BulletProjectile", attacking.parentTransform.position, targets[0], false); //                float rotationSpeed = 360, moveSpeed = 40;                while (!projectile.GetComponent<ProjectileFade>().hit)                {                    MoveAndRotateTowards(targets[0].parentTransform.position, projectile.transform, rotationSpeed, moveSpeed);                    yield return new WaitForFixedUpdate();                }                bool isCrit = Roll(attacking, "crit");                int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange, 1.1f);                StartCoroutine(CheckForMiss(false, explosion, targets[0], new(1f, 0.6f, 0f, 1f), projectile, moveSpeed, dmg, isCrit));                StartCoroutine(RemoveEffect(effect, attacking));            }            else            {                magicAudio.SetNewClip(gunClick, 1f);                effect.effectValue--;                yield return new WaitForSeconds(gunClick.length);                Destroy(explosion);            }        }        actionPerformed = true;    }    private IEnumerator PerformLaugh()    {        IEnumerator Explode(GameObject explosion, CharactersParameters target)        {            yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);            ReceiveEffect(new EffectDetails("Cold", 2, "effpurpblue", "EffectsTexture/Cold Texture", target), false);        }        GameObject cast = CreateCast("CastPrefab/Laugh", attacking.parentTransform.position);        yield return new WaitUntil(() => cast.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.9f);        List<GameObject> explosions = new();        for (int i = 0; i < targets.Count; i++)        {            explosions.Add(CreateExplosion("ExplosionPrefab/Scare", targets[i]));            explosions[i].SetActive(true);            StartCoroutine(WaitForEnd(explosions[i]));            StartCoroutine(Explode(explosions[i], targets[i]));        }        yield return new WaitUntil(() => explosions[targets.Count - 1] == null);        actionPerformed = true;    }    private IEnumerator PerformFixedShot()    {        GameObject cast = CreateCast("CastPrefab/ShotgunShot", attacking.parentTransform.position);        GameObject explosion = CreateExplosion("ExplosionPrefab/Shotgun", targets[0]);        bool isMiss = Roll(targets[0], "dodge");        GameObject projectile = CreateProjectile("ProjectilePrefab/BulletProjectile", attacking.parentTransform.position, targets[0], isMiss);        float rotationSpeed = 360, moveSpeed = 40;        while (!projectile.GetComponent<ProjectileFade>().hit)        {            MoveAndRotateTowards(targets[0].parentTransform.position, projectile.transform, rotationSpeed, moveSpeed);            yield return new WaitForFixedUpdate();        }        bool isCrit = Roll(attacking, "crit", -25);        int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);        StartCoroutine(CheckForMiss(isMiss, explosion, targets[0], new(1f, 0.6f, 0f, 1f), projectile, moveSpeed, dmg, isCrit));        yield return new WaitUntil(() => projectile == null);        if (!isMiss)        {            ReceiveEffect(new("Cold", 5, "effpurpblue", "EffectsTexture/Cold Texture", attacking), false);            ReceiveEffect(new("Stun", 2, "efforange", "EffectsTexture/Stun Texture", attacking), false);        }        actionPerformed = true;    }    private IEnumerator PerformCheerUp()    {        IEnumerator Explode(GameObject explosion, CharactersParameters target)        {            yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);            ReceiveEffect(new("Cheered", 3, "effgreen", "EffectsTexture/Cheered Texture", target), true);        }        AudioClip clip = Resources.Load<AudioClip>("Audio/Magic/Cheer");        magicAudio.SetNewClip(clip, 1f);        yield return new WaitForSeconds(clip.length - 0.3f);        List<GameObject> explosions = new();        for (int i = 0; i < targets.Count; i++)        {            explosions.Add(CreateExplosion("BuffPrefab/Cheer", targets[i]));            explosions[i].SetActive(true);            StartCoroutine(WaitForEnd(explosions[i]));            StartCoroutine(Explode(explosions[i], targets[i]));        }        yield return new WaitUntil(() => explosions[targets.Count - 1].GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 1);        actionPerformed = true;    }    private IEnumerator PerformBraindead()    {        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        GameObject explosion = CreateExplosion("BuffPrefab/RedDebuff", targets[0]);        bool isMiss = Roll(targets[0], "dodge");        GameObject projectile = CreateProjectile("ProjectilePrefab/WarpPortalGreen", attacking.parentTransform.position, targets[0], isMiss);        float rotationSpeed = 360, moveSpeed = 10;        while (!projectile.GetComponent<ProjectileFade>().hit)        {            MoveAndRotateTowards(targets[0].parentTransform.position, projectile.transform, rotationSpeed, moveSpeed);            moveSpeed++;            yield return new WaitForFixedUpdate();        }        bool isCrit = Roll(attacking, "crit");        int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);        StartCoroutine(CheckForMiss(isMiss, explosion, targets[0], new(0f, 0.6f, 0.05f, 1f), projectile, moveSpeed, dmg, isCrit));        yield return new WaitUntil(() => projectile == null);        if (!isMiss)        {            ReceiveEffect(new("Braindead", 3, "effpurple", "EffectsTexture/Braindead Texture", targets[0]), false);        }        actionPerformed = true;    }    private IEnumerator PerformRevenge()    {        GameObject cast = CreateCast(attacking.castPath, attacking.parentTransform.position);        yield return new WaitUntil(() => cast.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.6f);        GameObject explosion = CreateExplosion("BuffPrefab/Killjoy", targets[0]);        explosion.SetActive(true);        StartCoroutine(WaitForEnd(explosion));        yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);        ReceiveEffect(new("Contra", 3, "effpurpblue", "EffectsTexture/Contra Texture", targets[0]), true);        actionPerformed = true;    }    private IEnumerator PerformAgain()    {        IEnumerator Explode(GameObject explosion, CharactersParameters target)        {            yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);            ReceiveMana(target, Mathf.RoundToInt(target.maxMana * 0.30f));        }        GameObject cast = CreateCast("CastPrefab/Miku1", attacking.parentTransform.position);        yield return new WaitUntil(() => cast.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.9f);        List<GameObject> explosions = new();        for (int i = 0; i < targets.Count; i++)        {            if (targets[i] != attacking)            {                GameObject e = CreateExplosion("BuffPrefab/ManaRegen", targets[i]);                explosions.Add(e);                e.SetActive(true);                StartCoroutine(WaitForEnd(e));                StartCoroutine(Explode(e, targets[i]));            }        }        yield return new WaitUntil(() => explosions[^1] == null || explosions[^1].GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 1);        actionPerformed = true;    }    private IEnumerator PerformHeart()    {        IEnumerator Explode(GameObject explosion, CharactersParameters target)        {            yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);            bool isCrit = Roll(attacking, "crit");            Heal(target, GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange), isCrit, new(0f, 1f, 0.35f, 1f));        }        GameObject cast = CreateCast("CastPrefab/Miku2", attacking.parentTransform.position);        yield return new WaitUntil(() => cast.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.9f);        List<GameObject> explosions = new();        for (int i = 0; i < targets.Count; i++)        {            explosions.Add(CreateExplosion("BuffPrefab/Heal", targets[i]));            explosions[i].SetActive(true);            StartCoroutine(WaitForEnd(explosions[i]));            StartCoroutine(Explode(explosions[i], targets[i]));        }        yield return new WaitUntil(() => explosions[^1].GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 1);        actionPerformed = true;    }    private IEnumerator PerformRefrain()    {        GameObject cast = CreateCast("CastPrefab/Miku3", attacking.parentTransform.position);        yield return new WaitUntil(() => cast.GetComponent<Animator>().GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.9f);        GameObject explosion = CreateExplosion("ExplosionPrefab/Void", targets[0]);        explosion.SetActive(true);        StartCoroutine(WaitForEnd(explosion));        yield return new WaitUntil(() => explosion.GetComponent<ExplosionData>().explode);        ReceiveEffect(new("Sorrow", 3, "effblue", "EffectsTexture/Sorrow Texture", targets[0]), false);        ReceiveEffect(new("Stun", 1, "efforange", "EffectsTexture/Stun Texture", targets[0]), false);        actionPerformed = true;    }    private IEnumerator PerformLevanPolkka()    {        GameObject explosion = CreateExplosion("ExplosionPrefab/Leek", targets[0]);        ChangeStartPosition(explosion, 0f, 0.7f);        bool isMiss = Roll(targets[0], "dodge");        GameObject projectile = CreateProjectile("ProjectilePrefab/Leek", attacking.parentTransform.position, targets[0], isMiss);        float rotationSpeed = 360, moveSpeed = 15;        while (!projectile.GetComponent<ProjectileFade>().hit)        {            MoveAndRotateTowards(targets[0].parentTransform.position, projectile.transform, rotationSpeed, moveSpeed);            yield return new WaitForFixedUpdate();        }        bool isCrit = Roll(attacking, "crit");        int dmg = GetDmg(isCrit, usingSkill.skillValue, usingSkill.skillValueRange);        StartCoroutine(CheckForMiss(isMiss, explosion, targets[0], new(0.5f, 1f, 0f, 1f), projectile, moveSpeed, dmg, isCrit));        yield return new WaitUntil(() => projectile == null);        actionPerformed = true;    }    // Source code of color changing for recently used skill.    private IEnumerator LastUsedSkillGradientChange(Color color)    {        lastUsedSkill.gameObject.SetActive(true);        VertexGradient newGradient = new();        Color whiteColor = new(1f, 1f, 1f, 1f);        float r = color.r, g = color.g, b = color.b, a = color.a;        newGradient.bottomLeft = color;        newGradient.bottomLeft = color;        newGradient.topLeft = whiteColor;        newGradient.topRight = whiteColor;        lastUsedSkill.colorGradient = newGradient;        while (lastUsedSkill.colorGradient.bottomRight != new Color(1f, 1f, 1f, 1f))        {            if (r != 1f)            {                if (r > 1f)                {                    r = 1f;                }                r += lastUsedGradientSpeed * Time.deltaTime;            }            if (g != 1f)            {                if (g > 1f)                {                    g = 1f;                }                g += lastUsedGradientSpeed * Time.deltaTime;            }            if (b != 1f)            {                if (b > 1f)                {                    b = 1f;                }                b += lastUsedGradientSpeed * Time.deltaTime;            }            if (a != 1f)            {                if (a > 1f)                {                    a = 1f;                }                a += lastUsedGradientSpeed * Time.deltaTime;            }            newGradient.bottomRight = new Color(r, g, b, a);            newGradient.bottomLeft = new Color(r, g, b, a);            newGradient.topLeft = whiteColor;            newGradient.topRight = whiteColor;            lastUsedSkill.colorGradient = newGradient;            yield return new WaitForFixedUpdate();        }    }    private IEnumerator AlphaChange(GameObject obj)    {        obj.GetComponent<Animator>().SetTrigger("Hide");        yield return new WaitUntil(() => obj.GetComponent<TextMeshProUGUI>().color.a == 0);        obj.SetActive(false);    }    private List<SkillDetails> ExcludeSkills(CharactersParameters character, List<SkillDetails> list)    {        string name = character.name;        if (name == "Nagito Komaeda" && list.Count != 1)        {            list.Remove(list.Find(s => s.skillName == "Knife Stab")); //Nagito nie może używać umiejętności "Knfie Stab" dopóki ma mane.        }        else if (name == "Evil Marek")        {            bool pass = true;            foreach (CharactersParameters parameters in charParameters)            {                if (parameters.enemy && parameters.currentHP >= parameters.maxHP - 50)                {                    pass = false;                    break;                }            }            if (!pass)            {                list.Remove(list.Find(s => s.skillName == "Insulin Shot"));            }        } else if (name == "Mrożon")        {            if (character.effects.Exists(e => e.effectName == "Shield"))            {                list.Remove(list.Find(s => s.skillName == "Ice Cone"));            }            if (character.currentMana > 100)            {                list.Remove(list.Find(s => s.skillName == "Ice Wallow"));            }        }        return list;    }    private IEnumerator ChangeToFinish()    {        yield return new WaitUntil(() => !boss.charCollider.isActiveAndEnabled || !charParameters.Any(c => !c.enemy));        gameFinished = true;        yield return new WaitForSeconds(1);        GameObject fader = GameObject.Find("Fader");        AudioSource[] sources = GameObject.Find("Music Source").GetComponents<AudioSource>();        GameObject.Find("Settings").GetComponent<AudioSliders>().enabled = false;        GameObject.Find("Settings").SetActive(false);        GetComponent<StartGameAudio>().enabled = false;        while (fader.GetComponent<Image>().color.a < 0.95f)
        {
            foreach (AudioSource source in sources)
            {
                if(source.volume - Time.deltaTime/1.5f > 0)
                {
                    source.volume -= Time.deltaTime/1.5f;
                }
                else
                {
                    source.volume = 0;
                }
            }
            Color c = fader.GetComponent<Image>().color;
            c.a += Time.deltaTime/3f;
            fader.GetComponent<Image>().color = c;
            yield return new WaitForEndOfFrame();
        }
        SceneManager.LoadScene("EndGame");    }}